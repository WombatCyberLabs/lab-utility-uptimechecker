const request = require('request');
const net = require('net');
const dgram = require('dgram');
const config = require('./config.json');

const timeout = config.timeout;


const testService = async service=>{
	let results = [];
	if(service.http) results.push(await testWeb('http://',service));
	if(service.https) results.push(await testWeb('https://',service));
	if(service.ports.length){
		results = [...results, ...(await Promise.all(service.ports.map(async port=>{
			return await testPort(port,service, timeout);
		})))];
	}
	return results;
}


const testWeb = (protocol,service)=>{
	return new Promise((resolve,reject)=>{
		request({
			url:protocol + service.hostname + service.testPath,
			timeout
		},(err,res,body)=>{
			if(err) return resolve(fail(service,err,protocol));
			if(res.statusCode >= 400) resolve(fail(service, 'Error: status code ' + res.statusCode,protocol));
			else resolve(pass(service,protocol));
		});
	});

}

const testPort = async (port, service, timeout)=>{
	// Assume TCP protocol unless specified otherwise to preserve backwards compatibility with old configs
	if(port.protocol === 'udp')
		return await testUdp(port, service, timeout);
	return await testTcp(port, service, timeout);
}

const testTcp = (port,service, timeout)=>{
	return new Promise((resolve,reject)=>{
		try{
			const client = net.createConnection(port.port,service.hostname, () => {
				client.unref();
				resolve(pass(service,port));
			});
			client.setTimeout(timeout);
			client.on('timeout', () => {
				client.unref();
				client.destroy();
				resolve(fail(service,'Timed out',port));
			});
			client.on('error',e=>{
				resolve(fail(service,e,port));

			});
		}catch(e){
			console.error(e);
			reject(fail(service,'',port));
		}
	});
}

/*
	This is AI generated by taking the original testTcp function with the request of "rewrite this function to test a udp port"
	I want to spend as little time as possible making this work. Am I going to regret this? Probably.
*/
const testUdp = (port, service, timeout) => {
	return new Promise((resolve, reject) => {
	  try {
		let client = dgram.createSocket('udp4');
		
		client.on('message', (message, remote) => {
		  // Handle successful response
		  if(client) client.close();
		  client = null;
		  resolve(pass(service, port));
		});
  
		client.on('error', (error) => {
		  // Handle error
		  if(client) client.close();
		  client = null;
		  resolve(fail(service, error, port));
		});
  
		client.send(Buffer.from(port.probeMessage || ''), port.port, service.hostname, (error) => {
		  if (error) {
			// Handle error
			if(client) client.close();
			client = null;
			resolve(fail(service, error, port));
		  }
		});
  
		setTimeout(() => {
		  // Handle timeout
		  if(client) client.close();
		  client = null;
		  resolve(fail(service, 'Timed out', port));
		}, timeout);
	  } catch (e) {
		console.error(e);
		reject(fail(service, '', port));
	  }
	});
  };

const fail = (service,message,port)=>{
	return {
		success:false,
		name:(port && port.name)?port.name:service.name,
		hostname:service.hostname,
		port:port.hidden?null:port.port?port.port:port,
		message:String(message)
	}

}

const pass = (service,port)=>{
	return {
		success:true,
		name:(port && port.name)?port.name:service.name,
		hostname:service.hostname,
		port:port.hidden?null:port.port?port.port:port,
	}

}


const runTest = async ()=>{
	console.log('Starting test.');
	let results = (await Promise.all(config.services.map(async service=>{
		return await testService(service);
	}))).flat();
	console.log('Finished test.');
	return results;
}

module.exports = {
	runTest
}
